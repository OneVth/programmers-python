# 2025-12-31 학습 노트

## 📝 풀이한 문제 (1문제)

| 문제번호 | 제목 | 핵심 개념 | 복습 |
|---------|------|----------|:----:|
| 181867 | x 사이의 개수 | `split()` + `len()` 리스트 컴프리헨션 | |

---

## 🔁 복습한 문제 (1문제)

| 문제번호 | 제목 | 핵심 개념 | 복습 차수 |
|---------|------|----------|:---------:|
| 181832 | 정수를 나선형으로 배치하기 | 4방향 벡터, Spiral Matrix | 1차 |

---

## 🎯 핵심 학습 내용

### 1. split()의 동작 특성 이해 (문제 #181867)

**문제:** "x"를 기준으로 문자열을 나누고, 각 부분의 길이를 배열로 반환

**솔루션:**
```python
def solution(myString: str) -> list[int]:
    return [len(x) for x in myString.split("x")]
```

**split()의 핵심 동작:**

```python
# 1. 구분자가 연속되면 빈 문자열 포함
"axxb".split("x")  # ['a', '', 'b']

# 2. 시작/끝에 구분자가 있으면 빈 문자열 발생
"xabc".split("x")   # ['', 'abc']
"abcx".split("x")   # ['abc', '']
"xabcx".split("x")  # ['', 'abc', '']

# 3. 문자열 전체가 구분자인 경우
"xxx".split("x")    # ['', '', '', '']
```

**예제로 이해하기:**
```python
"oxooxoxxox".split("x")
# → ['o', 'oo', 'o', '', 'o', '']
# 길이: [1, 2, 1, 0, 1, 0]

"xabcxdefxghi".split("x")
# → ['', 'abc', 'def', 'ghi']
# 길이: [0, 3, 3, 3]
```

---

### 2. split() vs split(sep) 차이

**인자 없이 호출 시:**
```python
"  a  b  ".split()     # ['a', 'b'] - 연속 공백 무시, 양끝 trim
```

**구분자 지정 시:**
```python
"  a  b  ".split(" ")  # ['', '', 'a', '', 'b', '', ''] - 빈 문자열 유지
```

**이 차이가 중요한 이유:**
- 오늘 문제는 `split("x")`를 사용해서 빈 문자열이 보존됨
- 어제 문제(181866)는 빈 문자열을 필터링해야 했음

---

### 3. List Comprehension + 내장함수 패턴

**"변환 후 측정" 패턴:**
```python
# 각 요소의 길이
[len(x) for x in items]

# 각 요소의 합
[sum(x) for x in matrix]

# 각 요소의 최대값
[max(x) for x in groups]
```

**map() vs List Comprehension:**
```python
# map 사용
list(map(len, myString.split("x")))

# List Comprehension (더 Pythonic)
[len(x) for x in myString.split("x")]
```

---

### 4. Spiral Matrix - 4방향 벡터 패턴 (복습 #181832)

**문제:** n×n 배열에 1부터 n²까지 시계방향 나선형으로 배치

**핵심 패턴 (암기 추천):**
```python
directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 우, 하, 좌, 상
d = 0  # 현재 방향 인덱스

for i in range(1, n**2 + 1):
    mat[y][x] = i
    
    ny = y + directions[d][0]
    nx = x + directions[d][1]
    
    # 경계 벗어나거나 이미 방문했으면 방향 전환
    if ny < 0 or ny >= n or nx < 0 or nx >= n or mat[ny][nx]:
        d = (d + 1) % 4  # 시계 방향 회전
        ny = y + directions[d][0]
        nx = x + directions[d][1]
    
    y, x = ny, nx
```

**두 접근 방식 비교:**

| | ㄱ자 패턴 (v1) | 4방향 벡터 (v2) |
|---|---|---|
| 장점 | 수학적으로 정확한 개수 계산 | 직관적이고 확장 가능 |
| 단점 | 패턴 이해가 어려움 | 매번 경계 체크 필요 |
| 활용 | 나선형 특화 | 다양한 2D 탐색에 재사용 |

---

### 5. Python 변수 스코프 - `+=` 연산자 주의 (디버깅)

**발생한 에러:**
```
UnboundLocalError: cannot access local variable 'dy' where it is not associated with a value
```

**원인:**
```python
dy += dir[r][0]  # ❌ dy가 정의되지 않은 상태에서 += 사용
```

**이유:** `+=`는 `dy = dy + ...`와 같음. 오른쪽의 `dy`를 먼저 읽어야 하는데 값이 없음.

**수정:**
```python
dy = y + dir[r][0]  # ✅ 새 변수로 계산
```

---

## 🔗 연관 문제 비교

| 문제 | 작업 | 코드 |
|------|------|------|
| 181866 | x로 분할 → 빈 문자열 제거 → 정렬 | `sorted(s for s in my_string.split("x") if s)` |
| 181867 | x로 분할 → 각 부분 길이 | `[len(x) for x in myString.split("x")]` |

**공통점:** 둘 다 `split("x")` 사용
**차이점:** 181866은 빈 문자열 필터링 필요, 181867은 빈 문자열도 길이 0으로 포함

---

## 💡 오늘의 깨달음

1. **split(sep)은 빈 문자열 보존**: 구분자가 연속되거나 양끝에 있으면 빈 문자열 발생
2. **4방향 벡터 패턴**: `directions = [(0,1), (1,0), (0,-1), (-1,0)]` + `d = (d+1) % 4`
3. **`+=` 연산자 주의**: 변수가 정의되지 않은 상태에서 사용 불가 (읽기+쓰기 연산)
4. **연관 문제 비교 학습**: 비슷한 문제를 비교하면 패턴의 변형을 이해하기 좋음

---

## 📌 참고

- 프로그래머스 시스템 점검: 2025년 12월 31일 18시 ~ 2026년 1월 1일 09시
