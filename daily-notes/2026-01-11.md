# 2026-01-11 학습 노트

## 🔁 2차 복습 진행 (2문제 완료)

| 문제번호 | 제목 | 핵심 개념 | 복습 차수 | 결과 |
|---------|------|----------|:---------:|:----:|
| 181853 | 뒤에서 5등까지 | heapq.nsmallest | 2차 | ✅ |
| 181855 | 문자열 묶기 | Counter + 제너레이터 | 2차 | ✅ |

---

## 🎯 핵심 학습 내용

### 1. heapq.nsmallest vs sorted 성능 임계점 (문제 #181853)

**문제:** 리스트에서 가장 작은 k개 추출

```python
# v1: 정렬 후 슬라이싱 - O(n log n)
sorted(num_list)[:5]

# v2: heapq - O(n log k)
import heapq
heapq.nsmallest(5, num_list)
```

**심층 분석: 언제 무엇을 쓸까?**

이론상 heapq가 항상 유리해 보이지만, 실제 벤치마크는 다른 결과를 보여줌:

| k / n 비율 | 권장 방법 | 이유 |
|-----------|----------|------|
| < 10% | heapq | 압도적으로 빠름 |
| 10% ~ 35% | 상황에 따라 | 교차점 근처 |
| > 35% | sorted | 1.5~5배 빠름 |

**왜 sorted가 더 빠를 수 있는가?**
1. **Timsort 최적화**: 실제 데이터 패턴에 최적화
2. **캐시 친화성**: 연속 메모리 접근 vs 힙의 불규칙 접근
3. **C 구현 수준**: sorted는 완전히 C, heapq는 일부만 C

**CPython 내부 구현:**
```python
# n >= size일 때만 sorted로 전환 (100% 임계값)
if n >= size:
    return sorted(iterable, key=key)[:n]
```

> 📝 상세 내용: [notes/heapq-vs-sorted-threshold.md](../notes/heapq-vs-sorted-threshold.md)

---

### 2. Counter + 제너레이터 패턴 (문제 #181855)

**문제:** 문자열 길이별로 그룹핑 후 가장 큰 그룹 크기 반환

```python
from collections import Counter

def solution(strArr: list[str]) -> int:
    counter = Counter(len(s) for s in strArr)
    return max(counter.values())
```

**핵심 인사이트:**
- `Counter(len(s) for s in strArr)`: 제너레이터를 직접 전달하여 중간 리스트 생성 없이 카운팅
- 공간복잡도 O(k): k는 고유한 길이 수 (제한조건상 1~30 → 실질적 O(1))

---

## 📚 새로 작성한 노트

| 파일 | 주제 | 핵심 내용 |
|-----|------|----------|
| [heapq-vs-sorted-threshold.md](../notes/heapq-vs-sorted-threshold.md) | heapq vs sorted 성능 비교 | 임계점 분석, 벤치마크 데이터, 실전 가이드 |

---

## 📊 월간 복습 진행 현황 (16문제)

| 상태 | 문제번호 | 제목 | 핵심 개념 |
|:----:|---------|------|----------|
| ✅ | 120812 | 최빈값 구하기 | Counter.most_common() |
| ✅ | 120834 | 외계행성의 나이 | translate + maketrans |
| ✅ | 120837 | 개미 군단 | 그리디 vs DP |
| ✅ | 120846 | 합성수 찾기 | 에라토스테네스의 체 |
| ✅ | 120848 | 팩토리얼 | 점진적 계산 |
| ✅ | 120860 | 직사각형 넓이 | 좌표 정렬 |
| ✅ | 120864 | 숨어있는 숫자 (2) | re.findall |
| ✅ | 120866 | 안전지대 | Set 좌표 추적 |
| ✅ | 120886 | A로 B 만들기 | Counter 아나그램 |
| ✅ | 120888 | 중복된 문자 제거 | dict.fromkeys() |
| ✅ | 120891 | 369게임 | 문자열 카운팅 |
| ✅ | 181853 | 뒤에서 5등까지 | heapq.nsmallest() |
| ✅ | 181855 | 문자열 묶기 | Counter |
| ⬜ | 181856 | 배열 비교하기 | cmp 패턴, 튜플 비교 |
| ⬜ | 181861 | 배열의 원소만큼 추가하기 | chain.from_iterable() |
| ⬜ | 181862 | 세 개의 구분자 | re.split() |

**진행률: 13/16 (81%)**

---

## 🔄 다음 복습 예정

### 미완료 월간 복습 (3문제)
- [ ] 181856 — 배열 비교하기 (cmp 패턴)
- [ ] 181861 — 배열의 원소만큼 추가하기 (chain)
- [ ] 181862 — 세 개의 구분자 (re.split)

---

## 💡 오늘의 깨달음

1. **Big-O의 한계**: 이론적 시간복잡도와 실제 성능은 다를 수 있음 (상수 계수, 캐시 효과)
2. **경험적 임계점**: heapq vs sorted는 k/n ≈ 35%에서 교차 (데이터/환경에 따라 다름)
3. **코딩테스트 실전**: n ≤ 10,000 수준에서는 둘 다 충분히 빠르므로 가독성 우선
