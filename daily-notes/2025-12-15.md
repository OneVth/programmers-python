# 2025-12-15 학습 노트

## 오늘 푼 문제

| 번호 | 제목 | 핵심 개념 | 복습 |
|------|------|----------|:----:|
| 120897 | 약수 구하기 | 제곱근 최적화 O(√n), 완전제곱수 중복 처리 | 🔁 |
| 120898 | 편지 | 비트 시프트 `<< 1` = `* 2` | |
| 120899 | 가장 큰 수 찾기 | `max()` + `index()` vs `enumerate` 단일 순회 | |
| 120902 | 문자열 계산하기 | 스택 기반 계산기, `eval()` 보안 위험 | 🔁 |
| 120903 | 배열의 유사도 | Set 교집합 `&`, 해시 테이블 O(min(n,m)) | |
| 120904 | 숫자 찾기 | `index()` vs `find()` 차이점 | 🔁 |
| 120905 | n의 배수 고르기 | `filter()` vs 리스트 컴프리헨션, Lazy Evaluation | 🔁 |
| 120906 | 자릿수 더하기 | 문자열 vs 수학적 접근 (%, //) | |
| 120907 | OX퀴즈 | `split(" = ")`로 좌변/우변 분리, 음수 처리 | |
| 120908 | 문자열안에 문자열 | `in` 연산자 vs `find()` | |
| 120909 | 제곱수 판별하기 | `is_integer()` vs 역검증 `int(sqrt)**2 == n` | |
| 120910 | 세균 증식 | 비트 시프트 `n << t` = `n * 2^t` | |
| 120911 | 문자열 정렬하기 (2) | 메서드 체이닝 `"".join(sorted(s.lower()))` | |

## 오늘 배운 핵심 개념

### 1. index() vs find() - 문자열 검색 (120904)

```python
text = "hello"

# 찾으면 동일
text.index("l")  # 2
text.find("l")   # 2

# 못 찾을 때 - 핵심 차이!
text.index("z")  # ValueError 발생
text.find("z")   # -1 반환
```

**선택 기준:**
- 존재 확실 → `index()` (없으면 버그)
- 존재 불확실 → `find()` (조건문 처리)

→ `notes/str-index-vs-find.md`에 상세 정리

### 2. Lazy Evaluation (120905)

```python
# Eager (즉시 평가) - 메모리에 전부 저장
eager = [x ** 2 for x in range(1000000)]  # 8MB+

# Lazy (지연 평가) - 필요할 때만 계산
lazy = (x ** 2 for x in range(1000000))   # ~200 bytes
```

**핵심:**
- `[]` 대괄호 = Eager (리스트)
- `()` 소괄호 = Lazy (제너레이터)
- `filter()`, `map()`, `range()` 모두 Lazy

→ `notes/lazy-evaluation.md`에 상세 정리

### 3. eval() 보안 위험 (120902)

```python
# ❌ 절대 사용 금지 - 임의 코드 실행 가능
eval("__import__('os').system('rm -rf /')")

# ✅ 안전한 대안
import ast
ast.literal_eval("[1, 2, 3]")  # 리터럴만 파싱
```

**eval이 위험한 이유:**
- 파이썬 코드 그대로 실행
- `__builtins__` 접근으로 시스템 조작 가능
- 사용자 입력에 절대 사용 금지

→ `notes/eval-security.md`에 상세 정리

### 4. Set 내부 동작 원리 (120903)

```python
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}

# 교집합 - O(min(n, m))
a & b  # {3, 4}

# 합집합 - O(n + m)
a | b  # {1, 2, 3, 4, 5, 6}
```

**CPython 최적화:**
- 교집합: 작은 집합 순회 → 큰 집합에서 O(1) 탐색
- 합집합: 큰 집합 복사 → 작은 집합 추가

→ `notes/set-operations.md`에 내부 동작 추가

### 5. 비트 시프트 활용 (120898, 120910)

```python
n = 7
t = 3

# 2의 거듭제곱 곱셈
n * (2 ** t)  # 56
n << t        # 56 (더 빠름)

# 원리: 이진수 왼쪽 이동
# 7 = 111 → 111000 = 56
```

### 6. 제곱수 판별 - 부동소수점 안전성 (120909)

```python
n = 144

# 방법 1: is_integer() - 간결하지만 큰 수에서 오차 가능
(n ** 0.5).is_integer()  # True

# 방법 2: 역검증 - 더 안전
int(n ** 0.5) ** 2 == n  # True
```

**실전 팁:** 큰 수를 다룰 때는 역검증이 더 안전

## 오늘의 실수/반례

### 120897 - 약수 구하기 완전제곱수 중복

```python
n = 16  # √16 = 4

# ❌ 완전제곱수일 때 4가 두 번 추가됨
for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
        answer.append(i)
        answer.append(n // i)  # i=4일 때 16//4=4 중복!

# ✅ 조건 추가
if i != n // i:
    answer.append(n // i)
```

### 120897 - 시간복잡도 착각

```python
# ❌ O(√n)이 아님!
def solution(n):
    answer = []
    for i in range(1, int(n**0.5) + 1):  # O(√n)
        ...
    return sorted(answer)  # O(k log k) 정렬!

# ✅ 전체 시간복잡도: O(√n log √n) = O(√n log n)
```

## 생성한 노트

- `notes/str-index-vs-find.md` - index() vs find() 완벽 비교
- `notes/lazy-evaluation.md` - Lazy Evaluation 완벽 가이드
- `notes/eval-security.md` - eval() 보안 위험과 대안
- `notes/set-operations.md` - Set 내부 동작 원리 추가 (수정)

## 학습 통계

- 오늘 푼 문제: **13문제** 🎉
- 새로 배운 개념: Lazy Evaluation, eval 내부 동작, Set 해시 테이블 구현
- 생성한 노트: **4개** (신규 3개 + 수정 1개)

## 내일 할 일

- [ ] 120904 - `index()` vs `find()` 노트 복습
- [ ] 120905 - Lazy Evaluation 노트 복습
- [ ] 120902 - eval 보안 노트 복습
- [ ] Lv0 문제 계속 풀기
