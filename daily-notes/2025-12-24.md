# 2025-12-24 학습 노트

## 오늘 푼 문제

| 번호 | 제목 | 핵심 개념 | 상태 |
|------|------|----------|:----:|
| 181830 | 정사각형으로 만들기 | **In-place vs 새 배열 trade-off** | ✅ |
| 181831 | 특별한 이차원 배열 2 | **대칭 행렬**, 루프 최적화, zip(*arr) | ✅ |

## 오늘 학습한 핵심 개념

### 1. 2차원 배열 정사각형 만들기 (181830)

```python
# v1: In-place 수정 - O(1) 추가 공간
def solution_v1(arr):
    rows, cols = len(arr), len(arr[0])
    if rows > cols:
        for row in arr:
            row.extend([0] * (rows - cols))
    elif cols > rows:
        arr.extend([[0] * cols for _ in range(cols - rows)])
    return arr

# v2: 새 배열 생성 - O(m²) 공간, 더 깔끔
def solution_v2(arr):
    rows, cols = len(arr), len(arr[0])
    m = max(rows, cols)
    result = [[0] * m for _ in range(m)]
    for i in range(rows):
        for j in range(cols):
            result[i][j] = arr[i][j]
    return result
```

**Trade-off:**
| | In-place | 새 배열 |
|---|---|---|
| Space | O(1) 추가 | O(m²) |
| 원본 보존 | ❌ 수정됨 | ✅ 유지 |
| 코딩 테스트 | 부작용 주의 | 안전하고 권장 |

### 2. 대칭 행렬 판별 - 3가지 접근 (181831)

```python
# v1: 모든 쌍 비교 - O(n²)
def solution_v1(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n):  # n² 번
            if arr[i][j] != arr[j][i]:
                return 0
    return 1

# v2: 전치행렬과 비교 - O(n²) 공간
def solution_v2(arr):
    return int(arr == list(map(list, zip(*arr))))

# v3: 상삼각만 비교 - O(n²/2) 최적
def solution_v3(arr):
    n = len(arr)
    for i in range(n):
        for j in range(i + 1, n):  # n(n-1)/2 번
            if arr[i][j] != arr[j][i]:
                return 0
    return 1
```

### 3. 가짜 최적화 vs 진짜 최적화

```python
# 가짜 최적화 - 루프 횟수 동일!
for i in range(n):
    for j in range(n):      # 여전히 n² 번 반복
        if i >= j:
            continue        # 조건 검사만 추가 (오버헤드)
        ...

# 진짜 최적화 - 루프 범위 자체를 줄임
for i in range(n):
    for j in range(i + 1, n):  # 루프 자체가 n(n-1)/2 번!
        ...
```

**성능 측정 결과 (n=100):**
```
v1 (전체):     0.32s  (10,000번 비교)
v3_fake:       0.28s  (10,000번 루프 + continue)
v3_real:       0.15s  (4,950번 루프) ← 약 2배 빠름!
```

### 4. zip(*arr) - 전치행렬 만들기

```python
arr = [[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]]

# Step 1: *arr로 언패킹
# zip([1,2,3], [4,5,6], [7,8,9])

# Step 2: zip이 같은 인덱스끼리 묶음
# (1, 4, 7), (2, 5, 8), (3, 6, 9)

# Step 3: tuple → list 변환
transposed = list(map(list, zip(*arr)))
# [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
```

**원리:**
- `*arr`: 행들을 개별 인자로 언패킹
- `zip()`: 각 인자의 같은 인덱스 원소끼리 묶음 (세로로 묶기)
- 결과: 행↔열 교환 = 전치(transpose)

**대칭 행렬의 성질:** `A == Aᵀ` (전치해도 자기 자신과 같음)

## 성능 측정 스크립트

```python
import timeit

def solution_v1(arr):
    """모든 쌍 비교"""
    n = len(arr)
    for i in range(n):
        for j in range(n):
            if arr[i][j] != arr[j][i]:
                return 0
    return 1

def solution_v3_fake(arr):
    """가짜 최적화: continue 사용"""
    for i in range(len(arr)):
        for j in range(len(arr)):
            if i >= j:
                continue
            if arr[i][j] != arr[j][i]:
                return 0
    return 1

def solution_v3_real(arr):
    """진짜 최적화: 루프 범위 조정"""
    n = len(arr)
    for i in range(n):
        for j in range(i + 1, n):
            if arr[i][j] != arr[j][i]:
                return 0
    return 1

# 대칭 행렬 생성
n = 100
arr = [[i + j for j in range(n)] for i in range(n)]

print('=== 루프 횟수 비교 (n=100) ===')
print(f'v1:        {n*n} 번')
print(f'v3_fake:   {n*n} 루프 + {n*n} 번 i>=j 검사')
print(f'v3_real:   {n*(n-1)//2} 번')

print()
print('=== 실제 성능 측정 ===')
t1 = timeit.timeit(lambda: solution_v1(arr), number=1000)
t3_fake = timeit.timeit(lambda: solution_v3_fake(arr), number=1000)
t3_real = timeit.timeit(lambda: solution_v3_real(arr), number=1000)

print(f'v1:        {t1:.4f}s')
print(f'v3_fake:   {t3_fake:.4f}s')
print(f'v3_real:   {t3_real:.4f}s')
```

## 오늘의 핵심 패턴 정리

| 패턴 | 적용 문제 | 핵심 |
|------|----------|------|
| In-place vs 새 배열 | 181830 | 부작용 vs 메모리 trade-off |
| 대칭성 활용 최적화 | 181831 | `range(i+1, n)`으로 절반만 검사 |
| zip(*arr) 전치 | 181831 | 언패킹 + 같은 인덱스 묶기 |

## 관련 노트

- [symmetric-matrix-loop-optimization.md](../notes/symmetric-matrix-loop-optimization.md)

## 학습 통계

- 새 문제 풀이: **2문제**
- 핵심 인사이트: 가짜 최적화(continue) vs 진짜 최적화(range 조정)
- 성능 테스트 실습 진행
