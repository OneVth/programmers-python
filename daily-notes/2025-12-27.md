# 2025-12-27 학습 노트

## 📝 풀이한 문제 (11문제)

| 문제번호 | 제목 | 핵심 개념 | 복습 |
|---------|------|----------|:----:|
| 181844 | 배열의 원소 삭제하기 | set 변환으로 조회 O(1) 최적화 | 🔁 |
| 181845 | 문자열로 변환 | `str()` 타입 변환 | |
| 181846 | 두 수의 합 | Python 임의 정밀도 정수 (BigInt) | |
| 181847 | 0 떼기 | `lstrip()`, leading zeros 제거 | 🔁 |
| 181848 | 문자열을 정수로 변환하기 | `int()` 타입 변환 | |
| 181849 | 문자열 정수의 합 | 제너레이터 + `sum()` + `map()` | |
| 181850 | 정수 부분 | `int()`로 실수 버림 | |
| 181851 | 전국 대회 선발 고사 | 조건부 정렬, enumerate 활용 | |
| 181852 | 뒤에서 5등 위로 | 정렬 + 슬라이싱 `[5:]` | |
| 181853 | 뒤에서 5등까지 | 정렬 + 슬라이싱 `[:5]`, `heapq.nsmallest` | 🔁 |
| 181854 | 배열의 길이에 따라 다른 연산하기 | 조건부 인덱스 연산, in-place vs 새 리스트 | |

---

## 🎯 핵심 학습 내용

### 1. 타입 변환 함수 총정리

오늘 여러 문제에서 타입 변환이 핵심이었다:

| 함수 | 변환 | 예시 |
|------|------|------|
| `str()` | any → str | `str(123)` → `"123"` |
| `int()` | str/float → int | `int("10")` → `10`, `int(1.9)` → `1` |
| `float()` | str/int → float | `float("1.5")` → `1.5` |

**`int()`의 두 가지 역할:**
1. 문자열 파싱: `int("123")` → `123`
2. 실수 버림 (truncate): `int(3.7)` → `3`

---

### 2. Python 임의 정밀도 정수 (BigInt)

문제 #181846에서 10만 자리 숫자 덧셈 등장:

```python
# Python은 int가 자동으로 BigInt!
a = "18446744073709551615"
b = "287346502836570928366"
result = str(int(a) + int(b))  # 그냥 동작함
```

**다른 언어와 비교:**
- JavaScript: `BigInt` 타입 + `n` 접미사
- Java: `BigInteger` 클래스 (메서드 호출)
- C++: 표준 라이브러리에 없음 (Boost 필요)

→ 상세 내용: `notes/bigint-cross-language.md`

---

### 3. set vs list의 `in` 연산자 시간복잡도

문제 #181844에서 최적화 적용:

```python
# v1: O(n*m) - 리스트 조회
return [x for x in arr if x not in delete_list]

# v2: O(n+m) - set 변환 후 조회
delete_set = set(delete_list)
return [x for x in arr if x not in delete_set]
```

| 자료구조 | `in` 시간복잡도 |
|----------|----------------|
| list | O(n) |
| set | O(1) |
| dict (키) | O(1) |

---

### 4. 정렬 + 슬라이싱 패턴

쌍둥이 문제 #181852, #181853:

```python
sorted(lst)[5:]   # 가장 작은 5개 제외
sorted(lst)[:5]   # 가장 작은 5개 선택
sorted(lst)[-5:]  # 가장 큰 5개 선택
sorted(lst)[:-5]  # 가장 큰 5개 제외
```

**heapq 대안 (k << n일 때 효율적):**
```python
import heapq
heapq.nsmallest(5, lst)  # O(n log k)
heapq.nlargest(5, lst)   # O(n log k)
```

→ 상세 내용: `notes/heapq-nsmallest-nlargest.md`

---

### 5. 조건부 정렬과 인덱스 보존

문제 #181851 (전국 대회 선발 고사):

```python
# 나중에 인덱스가 필요하면 처음부터 함께 저장!
candidates = [(rank[i], i) for i in range(len(rank)) if attendance[i]]
candidates.sort()
a, b, c = [idx for _, idx in candidates[:3]]
```

**설계 원칙:** 나중에 필요한 정보는 처음부터 함께 저장

---

### 6. in-place 수정 vs 새 리스트 생성

문제 #181854에서 두 가지 접근:

```python
# v1: in-place - O(1) 공간, 원본 변경됨
arr[i] += n
return arr

# v2: 새 리스트 - O(n) 공간, 원본 보존
answer.append(arr[i] + n)
return answer
```

**트레이드오프:** 메모리 효율 vs 부작용 없는 안전한 코드

---

## 📚 생성한 학습 노트

- `notes/bigint-cross-language.md` - 임의 정밀도 정수 언어별 비교
- `notes/heapq-nsmallest-nlargest.md` - heapq로 상위/하위 k개 추출

---

## 💡 오늘의 깨달음

1. **Python의 강점**: BigInt가 내장되어 있어 별도 처리 없이 큰 수 연산 가능
2. **시간복잡도 최적화**: 반복 조회가 필요하면 list → set 변환 고려
3. **패턴 인식**: 정렬+슬라이싱은 "상위/하위 k개" 문제의 기본 패턴
4. **설계 원칙**: 나중에 필요한 정보(인덱스 등)는 처음부터 함께 저장
5. **타입 변환 시리즈**: `str()` ↔ `int()` ↔ `float()` 변환은 코딩 테스트 기초

---

## 🔄 다음에 복습할 것

- [ ] 181844 — set 변환으로 조회 최적화 (O(n) → O(1))
- [ ] 181847 — `lstrip()` 활용, leading zeros 처리
- [ ] 181853 — `heapq.nsmallest()` 언제 유리한지 판단
