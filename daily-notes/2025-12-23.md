# 2025-12-23 학습 노트

## 오늘 복습한 문제

| 번호 | 제목 | 핵심 개념 | 상태 |
|------|------|----------|:----:|
| 120905 | n의 배수 고르기 | **리스트 컴프리헨션 필터링** | ✅ |
| 120921 | 문자열 밀기 | **S+S 트릭**, deque.rotate() | ✅ |
| 120922 | 종이 자르기 | **수학 공식 M×N-1**, DP, 재귀 | ✅ |
| 120956 | 옹알이 (1) | **공백 치환**, 정규표현식 | ✅ |
| 181829 | 이차원 배열 대각선 순회 | **대각선 인덱스 i+j** | ✅ |

## 오늘 복습한 핵심 개념

### 1. 리스트 컴프리헨션 필터링 (120905)

```python
# n의 배수만 필터링
[x for x in numlist if x % n == 0]
```

**포인트:** `filter()` 함수보다 파이썬에서 더 관용적이고 가독성 좋음

### 2. 문자열 회전 검사 - S+S 트릭 (120921)

```python
# v1: B+B에서 A 찾기 - O(n)
def solution(A, B):
    return (B + B).find(A)

# v2: deque.rotate()로 시뮬레이션 - O(n²)
from collections import deque
a, b = deque(A), deque(B)
for i in range(len(A)):
    if a == b:
        return i
    a.rotate(1)
return -1
```

**원리:** `B + B`를 만들면 B의 모든 회전 상태가 부분 문자열로 포함됨
- `"ohell" + "ohell" = "ohellohell"` → `"hello"`, `"elloh"` 등 모든 회전 포함
- `find()`가 반환하는 인덱스 = 필요한 밀기 횟수
- 찾지 못하면 자동으로 `-1` 반환

### 3. 종이 자르기 - 수학적 통찰 (120922)

```python
# v1: 수학 공식 - O(1) ✨
def solution(M, N):
    return M * N - 1

# v2: DP - O(M²N + MN²)
# v3: 재귀 분할 - O(MN)
```

**원리:**
- M×N 종이를 1×1로 자르면 최종 M×N개의 조각
- 한 번 자를 때마다 조각이 정확히 1개 증가
- 1개 → M×N개 되려면 **M×N - 1**번 필요

**비유:** "n개의 노드를 연결하려면 n-1개의 간선이 필요" (트리 개념)

### 4. 옹알이 - 문자열 치환 vs 정규식 (120956)

```python
# v1: 공백 치환 후 확인
def solution(babbling):
    answer = 0
    for s in babbling:
        for word in ["aya", "ye", "woo", "ma"]:
            s = s.replace(word, " ")
        if not s.strip():
            answer += 1
    return answer

# v2: 정규표현식 - 더 선언적 ✨
import re
pattern = re.compile(r"^(aya|ye|woo|ma)+$")
return sum(1 for word in babbling if pattern.match(word))
```

**왜 공백(" ")으로 치환하는가:**
- `"woowo".replace("woo", "")` → `"wo"` (잘못된 결합 발생)
- `"woowo".replace("woo", " ")` → `" wo"` → strip 후 `"wo"` 남음 → 발음 불가 판정

**정규식 해석:**
- `^`: 문자열 시작
- `(aya|ye|woo|ma)+`: 발음 1회 이상 반복
- `$`: 문자열 끝

### 5. 대각선 순회 - 인덱스 패턴 (181829)

```python
def solution(board, k):
    answer = 0
    for i in range(len(board)):
        for j in range(len(board[0])):
            if i + j <= k:
                answer += board[i][j]
    return answer
```

**패턴:**
- `i + j = k`: 우상향 대각선 한 줄
- `i + j <= k`: 좌상단 삼각 영역

**최적화 가능 (가독성 vs 성능):**
```python
for i in range(min(k + 1, n)):
    for j in range(min(k - i + 1, m)):
        answer += board[i][j]
```

## 오늘의 핵심 패턴 정리

| 패턴 | 적용 문제 | 시간복잡도 |
|------|----------|-----------|
| 리스트 컴프리헨션 필터링 | 120905 | O(n) |
| S+S 문자열 회전 검사 | 120921 | O(n) |
| 수학 공식 유도 | 120922 | O(1) |
| 정규표현식 패턴 매칭 | 120956 | O(n*m) |
| 대각선 인덱스 조건 | 181829 | O(n*m) |

## 학습 통계

- 복습 완료: **5문제** (어제 대기 목록 전체 완료)
- 다양한 접근법 비교: 문자열 밀기(2가지), 종이 자르기(3가지), 옹알이(2가지)
- 학습 시간: 복습 세션 (format-solution 정리 포함)

## 다음 복습 준비

- [ ] Lv0 복습 대기 문제 확인
- [ ] Lv1 문제 도전 고려
