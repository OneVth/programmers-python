# 2026-01-02 학습 노트

## 🔁 월간 복습 (Monthly Review)

최근 4주간(W50~W01) weekly-notes에서 복습이 필요한 16개 문제의 2차 복습 파일 생성

### 생성된 review_2.py 파일 (16개)

| 문제번호 | 제목 | 핵심 개념 | 이월 횟수 |
|---------|------|----------|:---------:|
| 120812 | 최빈값 구하기 | Counter.most_common() | 1주 |
| 120834 | 외계행성의 나이 | translate + maketrans | **3주** |
| 120837 | 개미 군단 | 그리디 vs DP | **3주** |
| 120846 | 합성수 찾기 | 에라토스테네스의 체 | 1주 |
| 120848 | 팩토리얼 | bisect_left vs right | 1주 |
| 120860 | 직사각형 넓이 | zip(*) 언패킹 | **3주** |
| 120864 | 숨어있는 숫자 (2) | re.findall | **3주** |
| 120866 | 안전지대 | Set 좌표 추적 | **3주** |
| 120886 | A로 B 만들기 | Counter 아나그램 | **3주** |
| 120888 | 중복된 문자 제거 | dict.fromkeys() | **3주** |
| 120891 | 369게임 | 0 처리 주의 | **3주** |
| 181853 | 뒤에서 5등까지 | heapq.nsmallest() | 1주 |
| 181855 | 문자열 묶기 | Counter | 1주 |
| 181856 | 배열 비교하기 | cmp 패턴, 튜플 비교 | 1주 |
| 181861 | 배열의 원소만큼 추가하기 | chain.from_iterable() | 1주 |
| 181862 | 세 개의 구분자 | re.split() | 1주 |

---

## ✅ 복습 완료한 문제 (4문제)

| 문제번호 | 제목 | 핵심 개념 | 복습 차수 | 결과 | 재복습 |
|---------|------|----------|:---------:|:----:|:------:|
| 120812 | 최빈값 구하기 | Counter.most_common() | 2차 | ✅ | 🔄 |
| 120834 | 외계행성의 나이 | translate + maketrans | 2차 | ✅ | |
| 120837 | 개미 군단 | 그리디 vs DP | 2차 | ✅ | |
| 120846 | 합성수 찾기 | 에라토스테네스의 체 | 2차 | ✅ | 🔄 |

---

## 🎯 핵심 학습 내용

### 1. Counter.most_common(k) 내부 동작 (문제 #120812)

**문제:** 최빈값 반환, 여러 개면 -1

```python
from collections import Counter

# 방법 1: 수동 정렬 O(n log n)
sorted_counter = sorted(Counter(array).items(), key=lambda x: x[1], reverse=True)

# 방법 2: most_common() O(n log k) ← 최적
mc = Counter(array).most_common(2)
```

**핵심 인사이트:**
- `most_common(k)`는 내부적으로 `heapq.nlargest(k, ...)`를 사용
- 전체 정렬 O(n log n) 대신 상위 k개만 추출 O(n log k)
- k=2일 때 사실상 O(n)에 가까움!

**1차 복습 때 틀렸던 포인트:**
```python
# ❌ 인덱스 혼동
return mc[0][1]  # 빈도수 반환 (틀림)

# ✅ 정확한 코드
return mc[0][0]  # 요소 반환

# 💡 언패킹으로 실수 방지
element, count = mc[0]
```

---

### 2. translate + maketrans 패턴 (문제 #120834)

**문제:** 숫자 0~9를 알파벳 a~j로 변환

```python
# 방법 1: chr/ord (명시적, 길이가 김)
"".join(chr(ord('a') + int(c)) for c in str(age))

# 방법 2: translate (Pythonic, 간결)
str(age).translate(str.maketrans("0123456789", "abcdefghij"))
```

**동작 원리:**
1. `str.maketrans()`: Unicode 코드 포인트 매핑 딕셔너리 생성
2. `str.translate()`: 매핑을 O(1)로 조회하여 변환

**대량 문자 치환에 매우 효율적!**

---

### 3. 그리디 vs DP 판단 기준 (문제 #120837)

**문제:** 장군개미(5), 병정개미(3), 일개미(1)로 체력 hp를 맞추는 최소 개미 수

```python
# 그리디: O(1) ← 이 문제에서 최적
def solution_v1(hp: int) -> int:
    return (hp // 5) + (hp % 5 // 3) + (hp % 5 % 3)

# DP: O(n) - 동전 교환 문제 연습용
def solution_v2(hp: int) -> int:
    tab = [float("inf")] * (hp + 1)
    tab[0] = 0
    for i in range(1, hp + 1):
        if i >= 5: tab[i] = min(tab[i-5] + 1, tab[i])
        if i >= 3: tab[i] = min(tab[i-3] + 1, tab[i])
        tab[i] = min(tab[i-1] + 1, tab[i])
    return tab[hp]
```

**그리디가 성립하는 이유:**
- {5, 3, 1}에서 **1이 포함**되어 모든 자연수 표현 가능
- 3을 2개(=6)보다 5+1(=6)이 더 적은 개수
- **큰 단위를 최대한 사용하는 것이 항상 최적**

**그리디 실패 케이스:**
```python
# {6, 4, 1}로 8을 만들 때
# 그리디: 6+1+1 = 3개
# DP: 4+4 = 2개 ← 최적
```

---

### 4. 에라토스테네스의 체 - i*i 최적화 (문제 #120846)

**문제:** n 이하 합성수 개수 = n - 소수 개수 - 1

```python
def solution_v2(n: int) -> int:
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False

    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n + 1, i):  # i*i부터 시작!
                is_prime[j] = False

    return n - sum(is_prime) - 1
```

**왜 i*i부터 시작하나?**
```
i=5일 때:
5*2 = 10 → 2의 배수로 이미 제거됨
5*3 = 15 → 3의 배수로 이미 제거됨
5*4 = 20 → 2의 배수로 이미 제거됨
5*5 = 25 → 여기서부터 시작! ✅
```

**1차 복습 때 틀렸던 포인트:**
```python
# ❌ range 경계 오류
for i in range(4, n):      # n 미포함
    for j in range(2, int(n**0.5) + 1):  # n의 제곱근

# ✅ 수정
for i in range(4, n + 1):  # n 포함
    for j in range(2, int(i**0.5) + 1):  # i의 제곱근
```

---

## 📊 복습 효과 분석

### 2차 복습에서 개선된 점

| 문제 | 1차 복습 실수 | 2차 복습 개선 |
|------|-------------|--------------|
| 120812 | 튜플 인덱스 혼동 | most_common() 정확히 사용 ✅ |
| 120834 | chr/ord만 사용 | translate 패턴 체화 ✅ |
| 120837 | DP만 시도 | 그리디 적용 조건 이해 ✅ |
| 120846 | range 경계, √n 변수 혼동 | i*i 최적화 적용 ✅ |

### 시간복잡도 비교

| 문제 | 1차 접근 | 2차 접근 |
|------|---------|---------|
| 120812 | O(n log n) 수동 정렬 | O(n log k) most_common |
| 120837 | O(n) DP | O(1) 그리디 |
| 120846 | O(n√n) 단순 판별 | O(n log log n) 체 |

---

## 📚 관련 노트

- [notes/sieve-of-eratosthenes.md](../notes/sieve-of-eratosthenes.md) - 에라토스테네스의 체 상세
- [notes/collections-counter.md](../notes/collections-counter.md) - Counter 활용법
- [notes/str-translate-maketrans.md](../notes/str-translate-maketrans.md) - 문자 변환 패턴
- [notes/dp-greedy.md](../notes/dp-greedy.md) - DP vs 그리디 판단

---

## 🔄 다음 복습 예정

### 오늘 복습 중 재복습 필요
- [ ] 120812 — 최빈값 구하기 (Counter 인덱스)
- [ ] 120846 — 합성수 찾기 (에라토스테네스 체)

### 미완료 월간 복습 (12문제)
- [ ] 120848 — 팩토리얼 (bisect)
- [ ] 120860 — 직사각형 넓이 (zip(*))
- [ ] 120864 — 숨어있는 숫자 (2) (re.findall)
- [ ] 120866 — 안전지대 (Set 좌표)
- [ ] 120886 — A로 B 만들기 (Counter 아나그램)
- [ ] 120888 — 중복된 문자 제거 (dict.fromkeys())
- [ ] 120891 — 369게임 (0 처리)
- [ ] 181853 — 뒤에서 5등까지 (heapq)
- [ ] 181855 — 문자열 묶기 (Counter)
- [ ] 181856 — 배열 비교하기 (cmp 패턴)
- [ ] 181861 — 배열의 원소만큼 추가하기 (chain)
- [ ] 181862 — 세 개의 구분자 (re.split)

---

## 💡 오늘의 깨달음

1. **most_common(k)의 heapq 최적화**: k가 작으면 전체 정렬보다 훨씬 효율적
2. **translate는 대량 문자 치환의 정석**: chr/ord보다 간결하고 효율적
3. **그리디 적용 가능 여부 판단이 핵심**: 1이 포함되면 대부분 그리디 가능
4. **에라토스테네스 체의 i*i 최적화**: 작은 소수의 배수는 이미 제거됨
5. **월간 복습의 가치**: 3주 이상 이월된 문제들이 장기 기억으로 전환되는 느낌!
