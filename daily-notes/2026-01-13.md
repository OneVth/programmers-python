# 2026-01-13 학습 노트

## 🔁 2차 복습 완료 (3문제)

| 문제번호 | 제목 | 핵심 개념 | 복습 차수 | 결과 |
|---------|------|----------|:---------:|:----:|
| 181856 | 배열 비교하기 | 튜플 비교 + cmp 패턴 | 2차 | ✅ |
| 181861 | 배열의 원소만큼 추가하기 | chain.from_iterable() | 2차 | ✅ |
| 181862 | 세 개의 구분자 | translate + split | 2차 | ✅ |

---

## 🎯 핵심 학습 내용

### 1. 튜플 비교 + cmp 패턴 (문제 #181856)

**문제:** 두 배열의 대소관계 비교 (길이 우선, 같으면 합 비교)

```python
def solution(arr1: list[int], arr2: list[int]) -> int:
    t1 = (len(arr1), sum(arr1))
    t2 = (len(arr2), sum(arr2))
    return (t1 > t2) - (t1 < t2)
```

**핵심 인사이트:**

1. **튜플의 사전순(lexicographic) 비교**: `(길이, 합)` 순서로 구성하면 문제 조건을 자연스럽게 인코딩
2. **cmp 패턴**: `(a > b) - (a < b)` → Python 2의 `cmp()` 함수와 동일
   - `a > b` → 1
   - `a < b` → -1
   - `a == b` → 0

**활용처:** 정렬 키, 우선순위 큐, 커스텀 비교 함수

---

### 2. chain.from_iterable vs for 루프 (문제 #181861)

**문제:** 각 원소 a를 a번 반복하여 리스트 생성

```python
# v1: for 루프 + += 연산
answer = []
for i in arr:
    answer += [i] * i

# v2: itertools.chain
from itertools import chain
list(chain.from_iterable([a] * a for a in arr))
```

**비교 분석:**

| 방식 | 장점 | 단점 |
|------|------|------|
| for + `+=` | 직관적, 디버깅 쉬움 | - |
| chain | lazy evaluation, 함수형 스타일 | 최종 `list()` 변환 시 메모리 동일 |

> 💡 `chain.from_iterable`은 **스트리밍 처리**가 필요한 대용량 데이터에서 진가 발휘

---

### 3. 다중 구분자 split 패턴 (문제 #181862)

**문제:** 여러 문자(a, b, c)를 구분자로 문자열 분리

```python
# v1: 정규식 문자 클래스
import re
[s for s in re.split(r"[abc]", myStr) if s]

# v2: translate + split (더 빠름!)
myStr.translate(str.maketrans("abc", "   ")).split()
```

**v2가 우수한 이유:**
1. `str.split()` 인자 없이 호출 → **연속 공백 자동 처리** (빈 문자열 필터링 불필요)
2. `translate()`는 완전한 C 구현 → 정규식보다 빠름
3. 코드가 더 간결함

**한계:** `maketrans`는 동일 길이 치환만 가능 (1:1 매핑)

---

## 📊 월간 복습 진행 현황 (16문제)

| 상태 | 문제번호 | 제목 | 핵심 개념 |
|:----:|---------|------|----------|
| ✅ | 120812 | 최빈값 구하기 | Counter.most_common() |
| ✅ | 120834 | 외계행성의 나이 | translate + maketrans |
| ✅ | 120837 | 개미 군단 | 그리디 vs DP |
| ✅ | 120846 | 합성수 찾기 | 에라토스테네스의 체 |
| ✅ | 120848 | 팩토리얼 | 점진적 계산 |
| ✅ | 120860 | 직사각형 넓이 | 좌표 정렬 |
| ✅ | 120864 | 숨어있는 숫자 (2) | re.findall |
| ✅ | 120866 | 안전지대 | Set 좌표 추적 |
| ✅ | 120886 | A로 B 만들기 | Counter 아나그램 |
| ✅ | 120888 | 중복된 문자 제거 | dict.fromkeys() |
| ✅ | 120891 | 369게임 | 문자열 카운팅 |
| ✅ | 181853 | 뒤에서 5등까지 | heapq.nsmallest() |
| ✅ | 181855 | 문자열 묶기 | Counter |
| ✅ | 181856 | 배열 비교하기 | cmp 패턴, 튜플 비교 |
| ✅ | 181861 | 배열의 원소만큼 추가하기 | chain.from_iterable() |
| ✅ | 181862 | 세 개의 구분자 | translate + split |

**진행률: 16/16 (100%) 🎉**

---

## 💡 오늘의 깨달음

1. **비교 우선순위의 튜플 인코딩**: 복잡한 비교 조건도 튜플 순서로 우아하게 표현 가능
2. **`split()` 무인자 호출의 힘**: 연속 공백 자동 처리로 빈 문자열 필터링 불필요
3. **`translate` > `re.split`**: 단순 문자 치환은 정규식보다 `translate`가 더 빠르고 간결

---

## 🏆 월간 복습 완료!

1월 월간 복습 16문제 모두 완료! 다음 단계로 Lv1 문제 또는 새로운 Lv0 문제 풀이 예정.
