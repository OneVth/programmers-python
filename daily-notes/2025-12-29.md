# 2025-12-29 학습 노트

## 📝 풀이한 문제 (5문제)

| 문제번호 | 제목 | 핵심 개념 | 복습 |
|---------|------|----------|:----:|
| 181859 | 배열 만들기 6 | 스택 시뮬레이션, `or` 패턴 기본값 처리 | |
| 181860 | 빈 배열에 추가, 삭제하기 | `zip` vs `enumerate`, 리스트 확장/슬라이싱 | |
| 181861 | 배열의 원소만큼 추가하기 | `sum([], [])` vs `chain.from_iterable` 성능 | 🔁 |
| 181862 | 세 개의 구분자 | `re.split` vs `replace+split`, `split()` 자동 필터링 | 🔁 |
| 181863 | rny_string | `str.replace()` 문자열 치환 | |

---

## 🎯 핵심 학습 내용

### 1. 스택 시뮬레이션 패턴 (문제 #181859)

스택의 마지막 원소와 현재 원소를 비교하여 조건부 push/pop:

```python
stk = []
for i in arr:
    if not stk:
        stk.append(i)
    elif stk[-1] == i:
        stk.pop()      # 같으면 제거
    else:
        stk.append(i)  # 다르면 추가

return stk or [-1]  # 빈 리스트면 [-1] 반환
```

**`or` 패턴으로 기본값 처리:**
```python
stk or [-1]           # stk이 빈 리스트면 [-1]
answer or ["EMPTY"]   # answer가 빈 리스트면 ["EMPTY"]
```
- 빈 리스트 `[]`는 falsy → `or` 뒤의 값 반환
- `if not stk: return [-1] else: return stk` 보다 간결

---

### 2. 리스트 확장 패턴 비교 (문제 #181860, #181861)

**방법 1: `+=` 연산자 (in-place 확장)**
```python
stk = []
for i in arr:
    stk += [i] * i  # 리스트를 직접 확장
```

**방법 2: `sum([], [])` - 한 줄이지만 비효율적!**
```python
sum([[a] * a for a in arr], [])  # O(n²) - 매번 새 리스트 생성
```

**방법 3: `chain.from_iterable` - 효율적인 함수형 스타일**
```python
from itertools import chain
list(chain.from_iterable([a] * a for a in arr))  # O(n)
```

**성능 비교:**
| 방법 | 시간 복잡도 | 특징 |
|------|-------------|------|
| `+=` 반복문 | O(n * m) | 가장 직관적, 면접에서 설명하기 좋음 |
| `sum([], [])` | O(n² * m) | 한 줄, 하지만 큰 데이터에서 느림 |
| `chain.from_iterable` | O(n * m) | 함수형 스타일, 가장 효율적 |

---

### 3. `zip` vs `enumerate` 선택 기준 (문제 #181860)

```python
# enumerate: 인덱스로 다른 배열 접근 필요할 때
for i, b in enumerate(flag):
    if b:
        stk.extend([arr[i]] * (arr[i] * 2))

# zip: 두 배열을 동시에 순회할 때 (더 깔끔!)
for val, b in zip(arr, flag):
    if b:
        stk += [val] * val * 2
```

**선택 기준:**
- 두 배열을 병렬로 사용 → `zip`
- 인덱스가 별도로 필요 → `enumerate`

---

### 4. 문자열 분할 패턴 (문제 #181862)

**방법 1: `re.split` (정규표현식)**
```python
import re
re.split(r"[abc]", myStr)  # 'a', 'b', 'c' 중 하나로 분할
# → ['', 'onlettu', 'etom', 'to'] - 빈 문자열 포함!
```

**방법 2: `replace` 체이닝 + `split()`**
```python
myStr.replace("a", " ").replace("b", " ").replace("c", " ").split()
# → ['onlettu', 'etom', 'to'] - 빈 문자열 자동 제거!
```

**`split()` vs `split(' ')` 차이:**
```python
"a  b  c".split()      # → ['a', 'b', 'c'] - 연속 공백 자동 처리
"a  b  c".split(' ')   # → ['a', '', 'b', '', 'c'] - 빈 문자열 포함
```

**`split()` 인자 없이 호출하면:**
- 모든 공백 문자(스페이스, 탭, 개행)를 구분자로 사용
- 연속된 공백을 하나로 취급
- 결과에 빈 문자열 포함 안 됨

---

### 5. 리스트 뒤에서 n개 제거 (문제 #181860)

```python
# 슬라이싱으로 뒤에서 n개 제거
stk = stk[:-n]   # 새 리스트 생성

# del로 in-place 제거
del stk[-n:]     # 원본 수정
```

**주의:** `stk[:-0]`은 빈 리스트를 반환! (0개 제거가 아님)
```python
stk[:-0]  # → [] (전체 제거됨!)
```
문제에서 "0개 제거"가 없다고 보장되지 않으면 별도 처리 필요.

---

## 💡 오늘의 깨달음

1. **`or` 패턴**: 빈 리스트/빈 문자열의 기본값 처리에 `or` 사용하면 간결
2. **`sum([], [])` 함정**: 간결해 보이지만 O(n²) - 큰 데이터에서 시간 초과 가능
3. **`split()` 무인자 호출**: 빈 문자열을 자동으로 필터링해줌
4. **`zip` 우선 고려**: 두 리스트 병렬 순회 시 `enumerate`보다 `zip`이 더 Pythonic
5. **스택 패턴 단순화**: 3가지 조건이 실제로는 2가지로 단순화됨 (빈 스택 OR 다르면 push, 같으면 pop)

---

## 🔄 다음에 복습할 것

- [ ] 181861 — `sum([], [])` vs `chain.from_iterable` 성능 차이 기억하기
- [ ] 181862 — `split()` 무인자 호출의 자동 필터링 특성
