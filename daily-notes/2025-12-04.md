# 2025-12-04 (수) 코딩테스트 일지

## 📝 오늘 푼 문제 (10문제)

| # | 문제 | 핵심 개념 | 복습 |
|---|------|-----------|:----:|
| 120806 | 두 수의 나눗셈 | `int()` 버림, 실수→정수 변환 | |
| 120807 | 숫자 비교하기 | 삼항 연산자 `a if cond else b` | |
| 120808 | 분수의 덧셈 | `gcd()`, `fractions.Fraction` | 🔁 |
| 120809 | 배열 두 배 만들기 | 리스트 컴프리헨션 vs map | |
| 120810 | 나머지 구하기 | `%`, `divmod()` | |
| 120811 | 중앙값 구하기 | `sorted()` + 인덱싱 | |
| 120812 | 최빈값 구하기 | `Counter.most_common()` | 🔁 |
| 120813 | 짝수는 싫어요 | `range(start, end, step)` | |
| 120814 | 피자 나눠 먹기 (1) | 올림 나눗셈 공식 | |
| 120815 | 피자 나눠 먹기 (2) | `lcm()` 최소공배수 | 🔁 |

---

## 🔁 다시 풀어볼 문제

- [ ] **#120808 분수의 덧셈** — GCD/Fraction 활용
- [ ] **#120812 최빈값 구하기** — Counter 활용, 인덱스 혼동 주의
- [ ] **#120815 피자 나눠 먹기 (2)** — LCM 수학적 접근

---

## 💡 오늘의 핵심 배움

### 1. list(map(...))은 안티패턴
```python
# ❌ 지양
list(map(lambda x: x * 2, arr))

# ✅ 권장
[x * 2 for x in arr]
```
- `map()`의 장점(지연 평가)이 `list()`로 감싸면 사라짐
- 리스트가 필요하면 컴프리헨션이 더 빠르고 가독성 좋음

### 2. Counter.most_common() 반환 형태
```python
Counter([1,1,2]).most_common(2)
# [(1, 2), (2, 1)]
#   ↑  ↑
#  요소 개수

mc[0][0]  # 요소 ← 이걸 반환해야 함!
mc[0][1]  # 개수
```

### 3. 올림 나눗셈 공식 (정수 연산)
```python
# n을 k로 나눈 올림
(n - 1) // k + 1  # 방법 1
(n + k - 1) // k  # 방법 2

# math.ceil은 실수 연산 → 부동소수점 오차 가능
```

### 4. LCM으로 "남김없이 나누기" 해결
```python
from math import lcm
# n명이 6조각 피자를 남김없이 나눠먹으려면?
lcm(n, 6) // 6  # 필요한 피자 판 수
```

### 5. fractions.Fraction 자동 기약분수
```python
from fractions import Fraction
Fraction(1, 2) + Fraction(3, 4)
# Fraction(5, 4) ← 자동으로 기약분수!
```

---

## ⚠️ 실수한 점

### 120812 - 인덱스 혼동
```python
# 처음에 작성한 코드
return mc[0][1]  # ❌ 빈도수를 반환

# 수정한 코드
return mc[0][0]  # ✅ 요소를 반환
```
- 테스트가 우연히 통과함 (숫자와 빈도수가 같았음)
- **교훈**: 반례를 직접 만들어서 테스트하자!

---

## 📚 새로 작성한 문서
- `notes/list-map-antipattern.md`
- `notes/collections-counter.md`

---

## 🔄 다음에 복습할 것
- [ ] Counter 다양한 메서드 (`elements()`, `subtract()`)
- [ ] LCM/GCD 활용 문제 더 풀어보기
- [ ] 올림/내림/반올림 차이 정리
