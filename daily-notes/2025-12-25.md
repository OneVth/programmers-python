# 2025-12-25 학습 노트

## 오늘 푼 문제

| 번호 | 제목 | 핵심 개념 | 상태 |
|------|------|----------|:----:|
| 181830 | 정사각형으로 만들기 | 새 배열 생성 방식 | ✅ (복습) |
| 181831 | 특별한 이차원 배열 2 | 상삼각 검사, zip(*arr) | ✅ (복습) |
| 181832 | 정수를 나선형으로 배치하기 | **Spiral Matrix**, 4방향 벡터 | 🔁 |
| 181833 | 특별한 이차원 배열 1 | **단위 행렬** 생성 | ✅ |
| 181834 | l로 만들기 | **max()로 문자 클램핑** | ✅ |
| 181835 | 조건에 맞게 수열 변환하기 3 | 조건 분기 최적화 | ✅ |

## 오늘 학습한 핵심 개념

### 1. Spiral Matrix - 4방향 벡터 패턴 (181832)

```python
def spiral_fill(n):
    answer = [[None] * n for _ in range(n)]
    # 4방향: 오른쪽 → 아래 → 왼쪽 → 위
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    y, x, d = 0, 0, 0
    
    for i in range(1, n**2 + 1):
        answer[y][x] = i
        ny, nx = y + directions[d][0], x + directions[d][1]
        
        # 회전 조건: 범위 초과 또는 이미 채워진 칸
        if ny < 0 or ny >= n or nx < 0 or nx >= n or answer[ny][nx]:
            d = (d + 1) % 4
            ny, nx = y + directions[d][0], x + directions[d][1]
        
        y, x = ny, nx
    
    return answer
```

**핵심:**
- `None` 초기화로 "채워짐" 판별 가능 (0과 구분)
- `(d + 1) % 4`로 방향 순환
- 범위 초과 OR 이미 채워진 칸 → 방향 전환

**대안 - ㄱ자 패턴:**
```python
# 각 레이어에서 가로 i-1개 + 세로 i개 = 2i-1개씩 채움
for i in range(n, 0, -1):
    for j in range(2 * i - 1):
        # 가로 이동 후 세로 이동
```

### 2. 단위 행렬 (Identity Matrix) 생성 (181833)

```python
# 효율적: 0 초기화 후 대각선만 1로 설정
def identity_matrix(n):
    answer = [[0] * n for _ in range(n)]
    for i in range(n):
        answer[i][i] = 1
    return answer
```

**왜 이 방식이 좋은가:**
- 0 초기화: O(n²) - 필수
- 대각선만 수정: O(n) - 최소한의 연산
- `[[int(i==j) for j in range(n)] for i in range(n)]`보다 효율적 (매번 비교 안 함)

### 3. 문자 ASCII 비교와 max() 활용 (181834)

```python
# 'l'보다 작은 문자를 'l'로 변환
"".join(max(c, 'l') for c in myString)

# 원리: 문자 비교는 ASCII 값으로 자동 변환
max('a', 'l')  # 'l' (97 < 108)
max('z', 'l')  # 'z' (122 > 108)
```

**암기 패턴:**
| 목적 | 코드 |
|------|------|
| 하한 클램핑 (최소값 보장) | `max(c, threshold)` |
| 상한 클램핑 (최대값 보장) | `min(c, threshold)` |

### 4. 조건 분기 최적화 (181835)

조건이 고정값일 때 루프 밖에서 판단:

```python
# ❌ 비효율적: 매 원소마다 k%2 검사 (n번)
[x * k if k % 2 else x + k for x in arr]

# ✅ 효율적: 한 번만 검사 (1번)
if k % 2:
    return [x * k for x in arr]
else:
    return [x + k for x in arr]
```

**원칙:** 루프 내에서 변하지 않는 조건은 루프 밖으로 빼기

## 복습 성과

### 181830 - 정사각형으로 만들기

새 배열 생성 방식으로 깔끔하게 풀이:
```python
n = max(len(arr), len(arr[0]))
answer = [[0] * n for _ in range(n)]
for i in range(len(arr)):
    for j in range(len(arr[0])):
        answer[i][j] = arr[i][j]
```

### 181831 - 대칭 행렬 판별

두 가지 접근법 모두 구현:
```python
# v1: 상삼각 영역만 검사 - O(n²/2), O(1) 공간
for i in range(n):
    for j in range(i + 1, n):
        if arr[i][j] != arr[j][i]:
            return 0

# v2: 전치행렬 비교 - 한 줄, O(n²) 공간
return int(arr == list(map(list, zip(*arr))))
```

## 오늘의 핵심 패턴 정리

| 패턴 | 적용 문제 | 핵심 |
|------|----------|------|
| 4방향 벡터 + 회전 | 181832 | `(d + 1) % 4`, None 초기화 |
| 단위 행렬 | 181833 | 0 초기화 후 대각선만 1 |
| max() 클램핑 | 181834 | `max(c, 'l')`로 하한 설정 |
| 조건 분기 최적화 | 181835 | 고정 조건은 루프 밖으로 |
| 상삼각 검사 | 181831 | `range(i+1, n)`으로 절반만 |

## 학습 통계

- 복습 완료: **2문제** (181830, 181831)
- 새 문제 풀이: **4문제** (181832~181835)
- 총: **6문제**
- 핵심 패턴: **5개**

## 관련 노트

- [notes/symmetric-matrix-loop-optimization.md](../notes/symmetric-matrix-loop-optimization.md) - 루프 최적화
- [notes/2d-array-diagonal.md](../notes/2d-array-diagonal.md) - 2D 배열 패턴
- [weekly-notes/2025-W52.md](../weekly-notes/2025-W52.md) - 주간 복습 정리
