# Python 리스트 초기화 - [0]*n vs [0 for _ in range(n)]

## 두 방식의 차이

| 방식 | 동작 | 속도 |
|------|------|------|
| `[0] * n` | 같은 객체 참조 복사 | 빠름 (~1.5µs) |
| `[0 for _ in range(n)]` | 매번 새 객체 생성 | 느림 (~25µs) |

## 기본 타입(immutable)에서는 동일

```python
# int, str, tuple 등 immutable은 둘 다 안전
a = [0] * 5                 # [0, 0, 0, 0, 0]
b = [0 for _ in range(5)]   # [0, 0, 0, 0, 0]

a[0] = 99
print(a)  # [99, 0, 0, 0, 0] - 다른 요소 영향 없음
```

## mutable 객체에서는 위험!

```python
# ❌ 위험: 같은 리스트를 참조
bad = [[0] * 3] * 3
bad[0][0] = 99
print(bad)  # [[99, 0, 0], [99, 0, 0], [99, 0, 0]] - 전부 바뀜!

# ✅ 안전: 각각 새 리스트 생성
good = [[0] * 3 for _ in range(3)]
good[0][0] = 99
print(good)  # [[99, 0, 0], [0, 0, 0], [0, 0, 0]] - 해당 요소만 변경
```

## 메모리 구조 시각화

```
[[0]*3] * 3 → 같은 객체 참조 (위험!)

┌─────┐
│ b[0]│──┐
├─────┤  │    ┌───────────┐
│ b[1]│──┼───→│ [0, 0, 0] │  ← 하나의 리스트
├─────┤  │    └───────────┘
│ b[2]│──┘
└─────┘


[[0]*3 for _ in range(3)] → 각각 새 객체 (안전!)

┌─────┐     ┌───────────┐
│ a[0]│────→│ [0, 0, 0] │
├─────┤     └───────────┘
│ a[1]│────→│ [0, 0, 0] │  ← 각각 다른 리스트
├─────┤     └───────────┘
│ a[2]│────→│ [0, 0, 0] │
└─────┘     └───────────┘
```

## 상황별 추천 방식

| 상황 | 추천 | 예시 |
|------|------|------|
| 1차원 숫자 배열 | `[0] * n` | `dp = [0] * 100` |
| 1차원 문자열 배열 | `[""] * n` | `arr = [""] * 10` |
| 2차원 배열 | `[[0]*m for _ in range(n)]` | `dp = [[0]*5 for _ in range(3)]` |
| dict 배열 | `[{} for _ in range(n)]` | `counters = [{} for _ in range(5)]` |
| set 배열 | `[set() for _ in range(n)]` | `groups = [set() for _ in range(5)]` |
| 객체 배열 | `[Class() for _ in range(n)]` | `nodes = [Node() for _ in range(5)]` |

## 핵심 규칙

```
* 연산자 = 참조 복사

immutable (int, str, tuple) → 안전, * 사용 가능
mutable (list, dict, set)   → 위험, comprehension 필수
```

## 자주 하는 실수

```python
# ❌ 2차원 DP 초기화 실수
dp = [[0] * n] * m        # 모든 행이 같은 리스트!

# ✅ 올바른 2차원 DP 초기화
dp = [[0] * n for _ in range(m)]

# ❌ 그래프 인접 리스트 초기화 실수
graph = [[]] * n          # 모든 노드가 같은 리스트!

# ✅ 올바른 인접 리스트 초기화
graph = [[] for _ in range(n)]
```

## 디버깅 팁

**증상**: "한 곳을 수정했는데 다른 곳도 같이 바뀐다"

**원인 확인**:
```python
# id()로 객체 주소 확인
bad = [[]] * 3
print(id(bad[0]), id(bad[1]), id(bad[2]))
# 140234567890 140234567890 140234567890 ← 같은 주소!

good = [[] for _ in range(3)]
print(id(good[0]), id(good[1]), id(good[2]))
# 140234567890 140234567891 140234567892 ← 다른 주소
```
