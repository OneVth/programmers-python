# Python 시퀀스(리스트/튜플) 비교 동작 원리

## 핵심 개념: 사전순(Lexicographic) 비교

Python의 리스트와 튜플은 **사전순 비교**를 수행합니다.  
문자열이 알파벳 순서로 비교되는 것과 동일한 원리입니다.

## 비교 알고리즘

```python
# 두 시퀀스 A, B를 비교할 때:
# 1. 첫 번째 요소부터 순차적으로 비교
# 2. 다른 요소를 발견하면 즉시 그 결과를 반환
# 3. 모든 요소가 같으면 길이로 비교
```

### 단계별 예시

```python
[2021, 12, 28] < [2021, 12, 29]

# Step 1: 2021 == 2021 → 같음, 다음 요소로
# Step 2: 12 == 12 → 같음, 다음 요소로
# Step 3: 28 < 29 → True 반환!
```

## 다양한 비교 예시

### 기본 비교

```python
# 첫 요소에서 결정
[1, 9, 9] < [2, 0, 0]  # True (1 < 2)
[3, 1, 4] > [2, 9, 9]  # True (3 > 2)

# 두 번째 요소에서 결정
[1, 2, 9] < [1, 3, 0]  # True (1==1, 2 < 3)

# 세 번째 요소에서 결정
[1, 2, 3] < [1, 2, 4]  # True (1==1, 2==2, 3 < 4)

# 모든 요소가 같음
[1, 2, 3] == [1, 2, 3]  # True
[1, 2, 3] < [1, 2, 3]   # False
```

### 길이가 다른 경우

```python
# 공통 부분이 같으면 긴 쪽이 "크다"
[1, 2] < [1, 2, 3]      # True (접두사가 같으면 짧은 쪽이 작음)
[1, 2, 3] > [1, 2]      # True

# 공통 부분에서 이미 결정되면 길이 무관
[1, 3] > [1, 2, 9, 9]   # True (1==1, 3 > 2에서 결정)
```

### 튜플도 동일하게 동작

```python
(2021, 12, 28) < (2021, 12, 29)  # True
(1, 2) < (1, 2, 3)               # True

# 리스트와 튜플 간 비교는 TypeError
[1, 2] < (1, 2)  # TypeError: '<' not supported
```

## 실전 활용 패턴

### 1. 날짜 비교 (년/월/일)

```python
date1 = [2021, 12, 28]
date2 = [2021, 12, 29]

# 복잡한 조건문 대신 한 줄로!
is_earlier = date1 < date2  # True
```

### 2. 버전 비교

```python
version1 = [1, 9, 2]   # v1.9.2
version2 = [1, 10, 0]  # v1.10.0

version1 < version2  # True (1==1, 9 < 10)
```

### 3. 좌표 정렬 (x 우선, y 차순)

```python
points = [(3, 2), (1, 5), (1, 2), (3, 1)]
sorted(points)  # [(1, 2), (1, 5), (3, 1), (3, 2)]
# x 기준 정렬 → x가 같으면 y 기준 정렬
```

### 4. 다중 조건 정렬

```python
students = [
    ("김철수", 85, 90),
    ("이영희", 90, 85),
    ("박민수", 85, 95),
]

# 점수(내림차순) → 이름(오름차순) 정렬
sorted(students, key=lambda x: (-x[1], x[0]))
# [('이영희', 90, 85), ('김철수', 85, 90), ('박민수', 85, 95)]
```

## Boolean → int 변환 트릭

```python
# True는 1, False는 0으로 변환됨
int(True)   # 1
int(False)  # 0

# 비교 결과를 0/1로 반환하고 싶을 때
def compare_dates(date1, date2):
    return int(date1 < date2)

compare_dates([2021, 12, 28], [2021, 12, 29])  # 1
compare_dates([2021, 12, 29], [2021, 12, 28])  # 0
```

## 주의사항

### 타입이 다른 요소 비교

```python
# Python 3에서는 서로 다른 타입 비교 시 TypeError
[1, 2] < [1, "a"]  # TypeError: '<' not supported between 'int' and 'str'

# 같은 타입끼리만 비교 가능
["a", "b"] < ["a", "c"]  # True
```

### 중첩 리스트도 재귀적으로 비교

```python
[[1, 2], [3, 4]] < [[1, 2], [3, 5]]  # True
# [1, 2] == [1, 2] → 다음 요소로
# [3, 4] < [3, 5] → True (3==3, 4 < 5)
```

## cmp 패턴: 비교 결과를 -1, 0, 1로 반환

Python 2의 `cmp()` 함수가 Python 3에서 제거되었지만, 다음 패턴으로 동일한 결과를 얻을 수 있습니다:

```python
# cmp 패턴: (a > b) - (a < b)
def cmp(a, b):
    return (a > b) - (a < b)

# 동작 원리 (bool은 int로 자동 변환)
# a > b: True - False  = 1 - 0 = 1
# a < b: False - True  = 0 - 1 = -1
# a == b: False - False = 0 - 0 = 0
```

### 실전 예시: 배열 비교하기 문제

```python
# 문제: 길이 우선 비교, 같으면 합계 비교
# arr1이 크면 1, arr2가 크면 -1, 같으면 0

def solution(arr1: list[int], arr2: list[int]) -> int:
    t1 = (len(arr1), sum(arr1))
    t2 = (len(arr2), sum(arr2))
    return (t1 > t2) - (t1 < t2)

# 튜플 비교가 문제 조건과 정확히 일치!
# 1. 첫 요소(길이)가 다르면 → 길이로 결정
# 2. 첫 요소 같으면 → 두 번째(합계)로 결정
```

### 조건문 방식 vs cmp 패턴

```python
# 조건문 방식 (명시적이지만 장황함)
def compare_v1(a, b):
    if a > b:
        return 1
    elif a < b:
        return -1
    return 0

# cmp 패턴 (간결함)
def compare_v2(a, b):
    return (a > b) - (a < b)
```

## 요약

| 상황 | 결과 |
|------|------|
| 첫 번째 다른 요소에서 A < B | A < B는 True |
| 모든 요소 동일, A가 더 짧음 | A < B는 True |
| 모든 요소 동일, 길이도 같음 | A == B |

**핵심:** 리스트/튜플 비교는 "앞에서부터 순차 비교 → 첫 차이에서 결정"
