# DP(Dynamic Programming)와 Greedy 알고리즘

## 1. Dynamic Programming (동적 프로그래밍)

### 개념
**큰 문제를 작은 문제로 나누고, 작은 문제의 답을 저장해서 재사용하는 기법**

```
핵심 아이디어:
- 같은 계산을 반복하지 않는다 (Memoization)
- 작은 문제 → 큰 문제 순서로 해결 (Bottom-Up)
```

### DP가 가능한 조건
| 조건 | 설명 | 예시 |
|------|------|------|
| 최적 부분 구조 | 큰 문제의 최적해가 작은 문제의 최적해로 구성됨 | 최단 경로, 최소 개수 |
| 중복 부분 문제 | 같은 작은 문제가 여러 번 등장 | 피보나치, 동전 교환 |

### DP 풀이 5단계 프레임워크

```
┌─────────────────────────────────────────────────────┐
│  1. 문제 유형 파악                                    │
│     "뭘 구하라는 거지?" → 최소? 최대? 경우의 수?        │
├─────────────────────────────────────────────────────┤
│  2. 상태(State) 정의                                 │
│     "dp[i]가 뭘 의미하지?" ← 가장 중요!               │
├─────────────────────────────────────────────────────┤
│  3. 점화식(Transition) 도출                          │
│     "dp[i]를 이전 값들로 어떻게 표현하지?"             │
├─────────────────────────────────────────────────────┤
│  4. 기저 조건(Base Case)                             │
│     "가장 작은 문제의 답은?"                          │
├─────────────────────────────────────────────────────┤
│  5. 정답 추출                                        │
│     "최종 답은 dp 어디에 있지?"                       │
└─────────────────────────────────────────────────────┘
```

### 상태 정의 팁
**문제의 "구하라"를 그대로 dp 정의에 넣기**

```python
# 문제: "최소 개미 수를 구하라"
dp[i] = "i 체력에 대한 최소 개미 수"

# 문제: "가장 긴 증가하는 부분 수열 길이를 구하라"
dp[i] = "i번째에서 끝나는 가장 긴 증가 부분 수열 길이"

# 문제: "경우의 수를 구하라"
dp[i] = "i를 만드는 경우의 수"
```

### 점화식 도출 팁: "마지막 선택" 기법
**"최종 상태에 도달하기 직전에 어떤 선택을 했을까?"**

```python
# 개미 군단: hp=7을 만들려면 마지막에 뭘 썼을까?
# 경우 1: 장군개미(5) → 그 전에 2 필요 → dp[2] + 1
# 경우 2: 병정개미(3) → 그 전에 4 필요 → dp[4] + 1
# 경우 3: 일개미(1)  → 그 전에 6 필요 → dp[6] + 1
dp[7] = min(dp[2], dp[4], dp[6]) + 1
```

### 대표적인 DP 유형

| 유형 | 상태 정의 | 점화식 패턴 |
|------|----------|------------|
| 동전 교환 | dp[i] = i원의 최소 동전 수 | dp[i] = min(dp[i-coin]) + 1 |
| 피보나치 | dp[i] = i번째 수 | dp[i] = dp[i-1] + dp[i-2] |
| 계단 오르기 | dp[i] = i번째까지 최대 점수 | dp[i] = max(dp[i-1], dp[i-2]) + score[i] |
| LIS | dp[i] = i에서 끝나는 최장 길이 | dp[i] = max(dp[j]) + 1 (j < i, arr[j] < arr[i]) |
| 배낭 문제 | dp[i][w] = i개, 용량 w의 최대 가치 | dp[i][w] = max(선택, 비선택) |

---

## 2. Greedy (탐욕) 알고리즘

### 개념
**매 순간 가장 좋아 보이는 선택을 하면 전체 최적해가 되는 기법**

```
핵심 아이디어:
- 현재 최선의 선택 = 전체 최선의 선택
- 한 번 선택하면 되돌아보지 않음
- DP보다 빠르지만, 항상 적용 가능하진 않음
```

### 그리디가 가능한 조건
| 조건 | 설명 |
|------|------|
| 탐욕적 선택 속성 | 현재의 최선이 전체의 최선을 보장 |
| 최적 부분 구조 | 부분 문제의 최적해가 전체 최적해 구성 |

### 그리디가 적용 가능한 문제 패턴

#### 패턴 1: 단위가 배수 관계인 동전 문제
```python
# 동전: 500, 100, 50, 10 (배수 관계)
# → 큰 단위부터 쓰면 최적해 보장
def coin_greedy(amount, coins=[500, 100, 50, 10]):
    count = 0
    for coin in coins:
        count += amount // coin
        amount %= coin
    return count
```

#### 패턴 2: 정렬 후 순차 처리
```python
# 회의실 배정: 끝나는 시간 기준 정렬 → 순서대로 선택
meetings.sort(key=lambda x: x[1])  # 끝나는 시간 기준
for meeting in meetings:
    if meeting[0] >= last_end:
        select(meeting)
```

#### 패턴 3: 가장 급한 것부터 처리
```python
# 마감 기한이 있는 작업: 마감 빠른 순서로 처리
tasks.sort(key=lambda x: x.deadline)
```

#### 패턴 4: 손해를 최소화하는 선택
```python
# 체육복 빌려주기: 여유분 있는 사람이 앞번호부터 빌려줌
# → 한 번 빌려주면 다른 선택지가 줄어들지 않음
```

### 그리디 적용 가능 여부 판단 체크리스트

```
□ 현재 선택이 이후 선택에 영향을 주지 않는가?
□ 큰 단위가 작은 단위의 배수인가? (동전 문제)
□ 정렬 후 순차 처리로 해결 가능한가?
□ "가장 ~한 것"을 선택하면 항상 이득인가?
□ 반례를 찾을 수 없는가?
```

### 그리디가 실패하는 예시

```python
# 동전: [1, 3, 4] → 배수 관계 아님!
# 6원을 만들 때:
# 그리디: 4 + 1 + 1 = 3개 ❌
# 최적:   3 + 3     = 2개 ✅
```

---

## 3. DP vs Greedy 비교

### 관계도
```
┌─────────────────────────────────────┐
│             DP 문제                  │
│                                     │
│   ┌─────────────────────┐           │
│   │    그리디 문제       │           │
│   │   (DP의 특수 케이스)  │           │
│   └─────────────────────┘           │
│                                     │
└─────────────────────────────────────┘

그리디 → DP: 거의 항상 가능 (그리디는 DP의 최적화)
DP → 그리디: 불가능한 경우 많음
```

### 비교표
| 항목 | DP | Greedy |
|------|-----|--------|
| 시간복잡도 | 보통 O(n²) 이상 | 보통 O(n) 또는 O(n log n) |
| 공간복잡도 | O(n) 이상 (테이블) | O(1) 가능 |
| 정확성 | 항상 최적해 보장 | 조건 만족 시에만 최적해 |
| 구현 난이도 | 상태/점화식 설계 필요 | 비교적 단순 |
| 적용 범위 | 넓음 | 좁음 (특정 패턴만) |

### 문제 접근 전략

```
1. 그리디로 풀릴 것 같은가?
   ├─ Yes → 반례 있는지 확인
   │        ├─ 반례 없음 → 그리디로 풀이
   │        └─ 반례 있음 → DP로 전환
   └─ No  → DP로 풀이

2. 면접/코테에서:
   - 그리디 풀이 제시 시 "왜 그리디가 최적인지" 설명 필수
   - 설명 못하면 DP가 더 안전
```

---

## 4. 연습 문제 추천

### DP 입문
- 피보나치 수열
- 계단 오르기 (백준 2579)
- 동전 교환 (프로그래머스)
- 정수 삼각형 (프로그래머스)

### Greedy 입문
- 동전 0 (백준 11047) - 배수 관계 동전
- 회의실 배정 (백준 1931)
- 체육복 (프로그래머스)
- ATM (백준 11399)

### DP vs Greedy 비교 연습
- 동전 문제: [1, 5, 10, 50, 100] → 그리디 가능
- 동전 문제: [1, 3, 4] → DP 필요
