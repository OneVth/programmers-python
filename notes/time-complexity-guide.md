# 시간복잡도 추론 가이드

> 제한 조건(입력 크기)을 보고 허용 가능한 시간복잡도를 빠르게 판단하는 방법

## 🎯 핵심 법칙: 10^8 규칙

대부분의 온라인 저지(OJ)는 **1초에 약 10^8(1억) 번의 단순 연산**을 기준으로 한다.

```
허용 연산 횟수 ≈ 시간제한(초) × 10^8
```

따라서 입력 크기 N이 주어지면, `f(N) ≤ 10^8`을 만족하는 시간복잡도 O(f(N))을 선택해야 한다.

---

## 📊 입력 크기별 허용 복잡도

| N 범위 | 최대 복잡도 | 연산 횟수 | 대표 알고리즘/기법 |
|--------|-------------|-----------|-------------------|
| **≤ 10** | O(N!) | 3,628,800 | 순열 완전탐색, 브루트포스 |
| **≤ 20** | O(2^N) | 1,048,576 | 부분집합, 비트마스킹 DP |
| **≤ 25** | O(2^N) | 33,554,432 | Meet in the Middle |
| **≤ 50** | O(N^4) | 6,250,000 | 4중 루프 DP |
| **≤ 100** | O(N³) | 1,000,000 | 플로이드-워셜, 행렬 곱셈 |
| **≤ 500** | O(N³) | 125,000,000 | 플로이드-워셜 (경계) |
| **≤ 1,000** | O(N²) | 1,000,000 | 2중 루프, 버블정렬 |
| **≤ 5,000** | O(N²) | 25,000,000 | 2중 루프 (여유 있음) |
| **≤ 10,000** | O(N²) | 100,000,000 | 2중 루프 (경계) |
| **≤ 100,000** | O(N log N) | 1,660,964 | 정렬, 이분탐색, 세그먼트 트리 |
| **≤ 1,000,000** | O(N) | 1,000,000 | 선형 탐색, 해시, 투 포인터 |
| **≤ 10,000,000** | O(N) | 10,000,000 | 단순 순회, 카운팅 |
| **> 10^8** | O(log N), O(1) | - | 수학 공식, 이분탐색 |

---

## 🔍 복잡도별 대표 알고리즘

### O(1) - 상수 시간
- 수학 공식 (등차수열 합, 조합 공식)
- 해시 테이블 조회
- 배열 인덱스 접근

### O(log N) - 로그 시간
- 이분 탐색
- 분할 정복의 깊이
- 균형 이진 트리 연산

### O(N) - 선형 시간
- 단순 순회
- 투 포인터
- 슬라이딩 윈도우
- 해시맵 활용

### O(N log N) - 선형 로그 시간
- 정렬 (퀵소트, 병합정렬)
- 우선순위 큐 N번 연산
- 이분탐색 N번 반복

### O(N²) - 이차 시간
- 2중 for문
- 버블/선택/삽입 정렬
- 2차원 DP

### O(N³) - 삼차 시간
- 플로이드-워셜
- 3중 for문
- 행렬 곱셈

### O(2^N) - 지수 시간
- 부분집합 탐색
- 비트마스킹 DP
- 백트래킹 (가지치기 없이)

### O(N!) - 팩토리얼 시간
- 순열 완전탐색
- 외판원 문제 (브루트포스)

---

## 💾 공간복잡도 (메모리 제한)

| 메모리 제한 | int 배열 최대 크기 | 2D 배열 (N×N) |
|-------------|-------------------|---------------|
| 128 MB | 약 3,200만 개 | 5,600 × 5,600 |
| 256 MB | 약 6,400만 개 | 8,000 × 8,000 |
| 512 MB | 약 1억 2,800만 개 | 11,300 × 11,300 |

> **계산법**: 1 int = 4 bytes → 128MB = 128 × 10^6 / 4 = 32 × 10^6

---

## 🐍 파이썬 특수 사항

파이썬은 C/C++보다 **약 10~50배 느림**. 따라서:

| 언어 | 1초 기준 연산 횟수 |
|------|-------------------|
| C/C++ | 10^8 |
| Java | 10^7 ~ 10^8 |
| **Python** | **10^6 ~ 10^7** |

### 파이썬 최적화 팁
```python
# ❌ 느림
for i in range(n):
    for j in range(n):
        result += arr[i][j]

# ✅ 빠름 - 내장 함수 활용
result = sum(sum(row) for row in arr)
```

- 내장 함수(`sum`, `max`, `min`, `count`)는 C로 구현되어 빠름
- 리스트 컴프리헨션이 for문보다 빠름
- `sys.stdin.readline()` 사용 (input()보다 빠름)

---

## 📝 실전 문제 풀이 흐름

```
1. 문제 읽기
      ↓
2. 제한 조건 확인 (N의 범위!)
      ↓
3. 허용 복잡도 계산
      ↓
4. 해당 복잡도의 알고리즘 선택
      ↓
5. 구현
```

### 예시

**문제**: 배열에서 두 수의 합이 K인 쌍 찾기

| N 범위 | 허용 복잡도 | 접근법 |
|--------|-------------|--------|
| N ≤ 1,000 | O(N²) | 2중 for문 브루트포스 |
| N ≤ 100,000 | O(N log N) | 정렬 + 투 포인터 |
| N ≤ 1,000,000 | O(N) | 해시셋 활용 |

---

## ⚠️ 주의사항

1. **상수 계수 무시하지 말 것**
   - O(N)이라도 10*N이면 N ≤ 10^7까지만 안전

2. **재귀 깊이 제한**
   - Python 기본 재귀 제한: 1,000
   - `sys.setrecursionlimit(10**6)` 설정 필요

3. **경계값 테스트**
   - 항상 최대 입력으로 시간 초과 여부 확인

4. **복잡도 개선 > 상수 최적화**
   - O(N²) → O(N log N) 개선이 상수 최적화보다 효과적

---

## 📚 Quick Reference

```
N ≤ 10     → 뭘 해도 됨 (완전탐색 OK)
N ≤ 20     → 2^N 가능 (비트마스킹)
N ≤ 100    → N³ 가능 (플로이드)
N ≤ 1,000  → N² 가능 (2중 루프)
N ≤ 100K   → N log N 필요 (정렬/이분탐색)
N ≤ 1M     → N 필요 (선형/해시)
N > 10M    → log N 또는 O(1) 필요
```
